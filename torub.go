package torub

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

//Convert a number into rubles
func Convert(res string) string {
	// На входе в переменной res должна находиться строка в формате "12345.67" (пример: 18102412990.42)
	h000 := []string{" миллиард", "", "а", "ов", " миллион", "", "а", "ов", " тысяч", "а", "и", "", " рубл", "ь", "я", "ей"}
	// Первым идет корень слова, затем окончание для цифры 1, затем для цифер 2-4, затем для всего больше 4 и нуля
	h100 := []string{"", "сто", "двести", "триста", "четыреста", "пятьсот", "шестьсот", "семьсот", "восемьсот", "девятьсот"}
	h010 := []string{"", "", "двадцать", "тридцать", "сорок", "пятьдесят", "шестьдесят", "семьдесят", "восемьдесят", "девяносто"}
	h011 := []string{"", "один", "два", "три", "четыре", "пять", "шесть", "семь", "восемь", "девять", "десять", "одиннадцать", "двенадцать", "тринадцать", "четырнадцать", "пятнадцать", "шестнадцать", "семнадцать", "восемнадцать", "девятнадцать"}
	pattern := "000000000000"
	result := " " + res[len(res)-2:] + " коп." // Копируем хвост с копейками в результат "как есть"
	res = res[:len(res)-3]                     // Выкидываем дробную часть с точкой из исходника
	res = pattern[:12-len(res)] + res          // Добавляем в исходник лидирующие нули из pattern
	// Разбиваем строку на подстроки, в каждой из которых пока по одной цифре
	raw := make([]string, len(res))
	for i, d := range res {
		raw[i] = string(d)
	}

	p := 0
	i := 0
	k := 0
	t := 0                               // Переменные
	for group := 0; group < 4; group++ { // Цикл по группам из трех цифр - триадам (12 знаков pattern = 4 триады)
		p = group * 3       // Индекс нулевого элемента группы относительно начала массива RAW
		t = toNum(raw[p+2]) // В raw[p] у нас сотни, p+1 - десятки, p+2 - единицы очередной нашей группы
		if toNum(raw[p+1]) == 1 {
			t = 0
		} // Высчитываем окончание подписи (-а, -ов, -ей...), если десятки=1 то на единицы даже не смотрим
		if t > 1 && t < 5 {
			t = 2
		} // Если единицы = 2,3,4, то добавка к индексу базы подписей +2 (м..ОВ, рублЕЙ)
		if t > 4 || t == 0 {
			t = 3
		} // Если 0 или 5+ то добавка 3 (единица так и остается добавкой 1)
		i = toNum(raw[p])   // Собственно сама цифра (начнем с разряда сотен)
		raw[p] = h100[i]    // Заменили сотни (разряд сотен - тупо подстановка)
		i = toNum(raw[p+1]) // Разряд десятков: если >=20 - тоже заменяем
		if i > 1 {
			raw[p+1] = h010[i]
			i = 0
		} // Заменили десятки (двадцать и больше)
		k = i*10 + (toNum(raw[p+2])) // Считаем индекс K (для массива h011)
		//!!!!
		if isNumber(raw[p+1]) {
			raw[p+1] = ""
		} // Пустоту в десятки если прошлой операцией не заменили на строку
		raw[p+2] = h011[k] // Заменили 0, 1... 9, 10, 11, 12 ... 19
		if group == 2 && k == 1 {
			raw[p+2] = "одна"
		} // В разряде тысяч один->одна)
		if group == 2 && k == 2 {
			raw[p+2] = "две"
		} // В разряде тысяч два->две)
		if group == 3 || len(raw[p]+raw[p+1]+raw[p+2]) > 0 { // Если подпись вообще нужна, то... (нужна если "рублей" или непустые триады)
			raw[p+2] += h000[group*4] // Добавляем подпись к единицам (корень)
			raw[p+2] += h000[group*4+t]
		} // Добавляем подпись к единицам (окончание)
	}
	res = strings.Join(raw, " ") + result
	res = trimSpaces(res)
	return toTitle(res)
}

func toNum(s string) int {
	num, err := strconv.ParseInt(s, 10, 32)
	if err != nil {
		fmt.Println("err:", err)
	}
	return int(num)
}

func isNumber(s string) bool {
	for _, c := range s {
		if !unicode.IsDigit(c) {
			return false
		}
	}
	return true
}

func trimSpaces(s string) string {
	re := regexp.MustCompile(" +")

	return strings.TrimSpace(re.ReplaceAllLiteralString(s, " "))
}

func toTitle(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToUpper(r)) + s[n:]
}
